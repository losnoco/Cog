#include "meta.h"
#include "../util/endianness.h"
#include "../coding/coding.h"

/* .WAVE - WayForward "EngineBlack" games [Mighty Switch Force! (3DS), Adventure Time: Hey Ice King! Why'd You Steal Our Garbage?! (3DS)] */
VGMSTREAM* init_vgmstream_wave(STREAMFILE* sf) {
    VGMSTREAM* vgmstream = NULL;
    uint32_t start_offset, extradata_offset, interleave;
    int channels, loop_flag, sample_rate, codec, version;
    int32_t num_samples, loop_start, loop_end;
    read_u32_t read_u32;
    read_s32_t read_s32;
    read_f32_t read_f32;


    /* checks */
    if (!is_id32be(0x00,sf, "VAW3") && /* Happy Feet Two (3DS) */
        !is_id32be(0x00,sf, "WWAV") && /* Mighty Switch Force! (beta) (Wii) */
        read_u32le(0x00,sf) != 0xE5B7ECFE &&  /* common LE (hashed something?)  */
        read_u32be(0x00,sf) != 0xE5B7ECFE &&
        read_u32be(0x00,sf) != 0xC9FB0C03)  /* NDS [Lalaloopsy, Adventure Time: HIKWYSOG (DS)] */
        return NULL;

    if (!check_extensions(sf, "wave"))
        return NULL;

    bool big_endian = read_u32be(0x00,sf) == 0xE5B7ECFE || is_id32be(0x00,sf, "WWAV");
    if (big_endian) {
        read_u32 = read_u32be;
        read_s32 = read_s32be;
        read_f32 = read_f32be;
    } else {
        read_u32 = read_u32le;
        read_s32 = read_s32le;
        read_f32 = read_f32le;
    }

    version = read_u32(0x04,sf); /* common=0x0000, VAW3=0x0002, 0x50000=WWAV */
    if (read_u32(0x08,sf) != get_streamfile_size(sf))
        goto fail;

    sample_rate = (int)read_f32(0x0c, sf); /* WHY */
    num_samples = read_s32(0x10, sf);
    loop_start  = read_s32(0x14, sf);
    loop_end    = read_s32(0x18, sf);

    codec       =  read_u8(0x1c, sf);
    channels    =  read_u8(0x1d, sf); // DS can only do mono
    if (read_u8(0x1e, sf) != 0x00) goto fail; /* unknown */
    if (read_u8(0x1f, sf) != 0x00) goto fail; /* unknown */

    start_offset = read_u32(0x20, sf);
    interleave   = read_u32(0x24, sf); /* typically half data_size */
    extradata_offset = read_u32(0x28, sf); /* always 0x2c */

    loop_flag = (loop_start > 0);
    /* some songs (ex. Adventure Time's m_candykingdom_overworld.wave) do full loops, but there is no way
     * to tell them apart from sfx/voices, so we try to detect if it's long enough. */
    if(!loop_flag
            && loop_start == 0 && loop_end == num_samples /* full loop */
            && (channels > 1 || (channels == 1 && start_offset <= 0x40))
            && num_samples > 30 * sample_rate) { /* in seconds */
        loop_flag = 1;
    }

    /* normalize codec (files generated by DsBuildWave/3dsBuildWave) */
    if (codec == 0x00 && version == 0x00050000 && start_offset > 0x40) {
        /* WWAV uses codec 0x00 for DSP (only one?) */
        codec = 0x02;
    }
    else if (codec == 0x02 && start_offset <= 0x40) {
        /* DS games use IMA, no apparent flag (could also test ID) */
        codec = 0x03;
    }


    /* build the VGMSTREAM */
    vgmstream = allocate_vgmstream(channels, loop_flag);
    if (!vgmstream) goto fail;

    vgmstream->sample_rate = sample_rate;
    vgmstream->num_samples = num_samples;
    vgmstream->loop_start_sample = loop_start;
    vgmstream->loop_end_sample = loop_end;

    vgmstream->meta_type = meta_WAVE;

    /* some codecs aren't used by known games but can be created by DsBuildWave/3dsBuildWave */
    switch(codec) {
        case 0x00: // PCM8 (not seen)
            vgmstream->coding_type = coding_PCM8;
            vgmstream->layout_type = layout_interleave;
            vgmstream->interleave_block_size = interleave;
            break;

        case 0x01: // PCM16 (not seen)
            vgmstream->coding_type = coding_PCM16BE;
            vgmstream->layout_type = layout_interleave;
            vgmstream->interleave_block_size = interleave;
            break;

        case 0x02: { // DSP (3DS only, common)
            vgmstream->coding_type = coding_NGC_DSP;
            vgmstream->layout_type = layout_interleave;
            vgmstream->interleave_block_size = interleave;

            /* ADPCM setup: 0x20 coefs + 0x06 initial ps/hist1/hist2 + 0x06 loop ps/hist1/hist2 + ?, per channel */
            int head_spacing = 0x2c;
            int hist_spacing = 0x22;
            if (version == 0x00050000) { /* has an extra empty 16b after coefs */
                head_spacing = 0x2e;
                hist_spacing = 0x24;
            }

            dsp_read_coefs(vgmstream, sf, extradata_offset + 0x00, head_spacing, big_endian);
            dsp_read_hist(vgmstream, sf, extradata_offset + hist_spacing, head_spacing, big_endian);
            break;
        }

        case 0x03: //IMA (DS uses codec 02 for IMA, common; 3DS: uses 03 but not seen)
            vgmstream->coding_type = coding_IMA_mono;
            vgmstream->layout_type = layout_interleave;
            vgmstream->interleave_block_size = interleave;

            /* extradata: 
             * 0x00: base hist? (only seen 0)
             * 0x02: base step? (only seen 0)
             * 0x04: loop hist?
             * 0x06: loop step?
             */
            break;

        default:
            goto fail;
    }

    if (!vgmstream_open_stream(vgmstream, sf, start_offset))
        goto fail;
    return vgmstream;

fail:
    close_vgmstream(vgmstream);
    return NULL;
}
