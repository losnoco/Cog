 #include "meta.h"
#include "../coding/coding.h"
#include "../util/meta_utils.h"

/* SWAR - wave container generated by the DS SDK */
VGMSTREAM* init_vgmstream_swar(STREAMFILE* sf) {

    /* checks */
    if (!is_id32be(0x00,sf, "SWAR"))
        return NULL;
    if (!check_extensions(sf, "swar"))
        return NULL;

    meta_header_t h = {0};
    h.meta = meta_SWAV;
    h.target_subsong = sf->stream_index;
    if (h.target_subsong == 0)
        h.target_subsong = 1;

    // wave container mainly for sequences, accesed through .sbnk
    // 0x04: BOM mark
    // 0x06: version? (1.00)
    h.data_size = read_u32le(0x08,sf);
    // 0x0c: always 16?
    // 0x0e: always 1?

    if (!is_id32be(0x10, sf, "DATA"))
        return NULL;
    // 0x14: chunk size (full)
    
    h.total_subsongs = read_s32le(0x38,sf);
    uint32_t head_offset = read_s32le(0x3c + (h.target_subsong - 1) * 0x04, sf);

    // "sample" header, similar to SWAV
    int codec       = read_u8   (head_offset + 0x00, sf);
    h.loop_flag     = read_u8   (head_offset + 0x01, sf) != 0;
    h.sample_rate   = read_u16le(head_offset + 0x02, sf);
    // 04 time units? (33.513982MHz/2 * time = samples?)
    h.loop_start    = read_u16le(head_offset + 0x06,sf); //in units
    h.loop_end      = read_s32le(head_offset + 0x08,sf); //length in units

    h.stream_offset = head_offset;
    uint32_t next_offset = h.target_subsong < h.total_subsongs ? 
        read_s32le(0x3c + (h.target_subsong) * 0x04, sf) : 
        h.data_size; 
    h.stream_size = next_offset - h.stream_offset;

    h.stream_offset += 0x10;
    h.stream_size -= 0x10;

    h.channels = 1;

    // same as SWAV
    int bits_per_sample;
    switch (codec) {
        case 0: // Phoenix Wright: Ace Attorney (DS)
            h.coding = coding_PCM8;
            bits_per_sample = 8;
            h.num_samples = pcm8_bytes_to_samples(h.stream_size, h.channels);
            break;
        case 1: // Electroplankton (DS)
            h.coding = coding_PCM16LE;
            bits_per_sample = 16;
            h.num_samples = pcm16_bytes_to_samples(h.stream_size, h.channels);
            break;
        case 2: // common
            h.coding = coding_IMA;
            bits_per_sample = 4;
            h.num_samples = ima_bytes_to_samples(h.stream_size, h.channels);
            break;
        default:
            VGM_LOG("SWAR: unknown format\n");
            return NULL;
    }

    h.loop_start = h.loop_start * 32 / bits_per_sample;
    h.loop_end = h.loop_end * 32 / bits_per_sample + h.loop_start;
    if (codec == 2) {
        // handle IMA frame header
        h.loop_start -= 32 / bits_per_sample;
        h.loop_end -= 32 / bits_per_sample;
    }


    h.layout = layout_none;
    h.sf = sf;
    h.open_stream = true;
    h.has_subsongs = true;

    VGMSTREAM* v = alloc_metastream(&h);
    if (!v) return NULL;

    v->ch[0].adpcm_history1_32 = read_s16le(head_offset + 0x0c, sf);
    v->ch[0].adpcm_step_index = read_u8(head_offset + 0x0e, sf);

    return v;
}
